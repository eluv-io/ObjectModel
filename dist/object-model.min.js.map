{"version":3,"file":"object-model.min.js","sources":["../src/helpers.js","../src/object-model.js","../src/list-model.js","../src/array-model.js","../src/function-model.js","../src/map-model.js","../src/set-model.js"],"sourcesContent":["export const\n\tObjectProto = Object.prototype,\n\tbettertypeof = x => ObjectProto.toString.call(x).match(/\\s([a-zA-Z]+)/)[1],\n\tgetProto = Object.getPrototypeOf,\n\tsetProto = Object.setPrototypeOf,\n\n\thas = (o, prop) => ObjectProto.hasOwnProperty.call(o, prop),\n\tis = (Constructor, obj) => obj instanceof Constructor,\n\tisFunction = f => typeof f === \"function\",\n\tisObject = o => o && typeof o === \"object\",\n\tisString = s => typeof s === \"string\",\n\tisPlainObject = o => isObject(o) && getProto(o) === ObjectProto,\n\tisIterable = x => x && isFunction(x[Symbol.iterator]),\n\n\tproxify = (val, traps) => new Proxy(val, traps),\n\n\tmerge = (target, src = {}) => {\n\t\tfor (let key in src) {\n\t\t\tif (isPlainObject(src[key])) {\n\t\t\t\tconst o = {}\n\t\t\t\tmerge(o, target[key])\n\t\t\t\tmerge(o, src[key])\n\t\t\t\ttarget[key] = o\n\t\t\t} else {\n\t\t\t\ttarget[key] = src[key]\n\t\t\t}\n\t\t}\n\t\treturn target\n\t},\n\n\tdefine = (obj, key, value, enumerable = false) => {\n\t\tObject.defineProperty(obj, key, { value, enumerable, writable: true, configurable: true })\n\t},\n\n\textend = (child, parent, props) => {\n\t\tchild.prototype = Object.assign(Object.create(parent.prototype, {\n\t\t\tconstructor: {\n\t\t\t\tvalue: child,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t}\n\t\t}), props)\n\t\tsetProto(child, parent)\n\t}","import {\r\n\tbettertypeof, define, extend, getProto, has,\r\n\tis, isFunction, isObject, isPlainObject, isString,\r\n\tmerge, ObjectProto, proxify, setProto\r\n} from \"./helpers.js\"\r\n\r\nexport const\r\n\t_check = Symbol(),\r\n\t_checked = Symbol(), // used to skip validation at instanciation for perf\r\n\t_original = Symbol(), // used to bypass proxy\r\n\tCHECK_ONCE = Symbol(),\r\n\r\n\tinitModel = (def, constructor, parent, init, getTraps, useNew) => {\r\n\t\tconst model = function (val = model.default, mode) {\r\n\t\t\tif (useNew && !is(model, this)) return new model(val)\r\n\t\t\tif (init) val = init(val, model, this)\r\n\r\n\t\t\tif (mode === _checked || check(model, val))\r\n\t\t\t\treturn getTraps && mode !== CHECK_ONCE ? proxify(val, getTraps(model)) : val\r\n\t\t}\r\n\r\n\t\tif (parent) extend(model, parent)\r\n\t\tsetProto(model, constructor.prototype)\r\n\t\tmodel.constructor = constructor\r\n\t\tmodel.definition = def\r\n\t\tmodel.assertions = [...model.assertions]\r\n\t\tdefine(model, \"errors\", [])\r\n\t\tdelete model.name\r\n\t\treturn model\r\n\t},\r\n\r\n\tinitObjectModel = (obj, model, _this) => {\r\n\t\tif (is(model, obj)) return obj\r\n\r\n\t\tif (!isObject(obj) && !isFunction(obj) && obj !== undefined) {\r\n\t\t\tstackError(model.errors, Object, obj)\r\n\t\t}\r\n\r\n\t\tmerge(_this, model.default)\r\n\t\tif (model.parentClass) merge(obj, new model.parentClass(obj))\r\n\t\tmerge(_this, obj)\r\n\t\treturn _this\r\n\t},\r\n\r\n\textendModel = (child, parent, newProps) => {\r\n\t\textend(child, parent, newProps)\r\n\t\tchild.assertions.push(...parent.assertions)\r\n\t\treturn child\r\n\t},\r\n\r\n\tstackError = (errors, expected, received, path, message) => {\r\n\t\terrors.push({ expected, received, path, message })\r\n\t},\r\n\r\n\tunstackErrors = (model, collector = model.errorCollector) => {\r\n\t\tconst nbErrors = model.errors.length\r\n\t\tif (nbErrors > 0) {\r\n\t\t\tconst errors = model.errors.map(err => {\r\n\t\t\t\tif (!err.message) {\r\n\t\t\t\t\terr.message = \"expecting \" + (err.path ? err.path + \" to be \" : \"\") + formatDefinition(err.expected)\r\n\t\t\t\t\t\t+ \", got \" + (err.received != null ? bettertypeof(err.received) + \" \" : \"\") + format(err.received)\r\n\t\t\t\t}\r\n\t\t\t\treturn err\r\n\t\t\t})\r\n\r\n\t\t\tmodel.errors.length = 0\r\n\t\t\tcollector.call(model, errors) // throw all errors collected\r\n\t\t}\r\n\t\treturn nbErrors\r\n\t},\r\n\r\n\tisModelInstance = i => i && getProto(i) && is(Model, getProto(i).constructor),\r\n\r\n\tparseDefinition = (def) => {\r\n\t\tif (isPlainObject(def)) {\r\n\t\t\tdef = {}\r\n\t\t\tfor (let key in def) { def[key] = parseDefinition(def[key]) }\r\n\t\t}\r\n\t\telse if (!Array.isArray(def)) return [def]\r\n\t\telse if (def.length === 1) return [def[0], undefined, null]\r\n\r\n\t\treturn def\r\n\t},\r\n\r\n\tformatDefinition = (def, stack) => {\r\n\t\tconst parts = parseDefinition(def).map(d => format(d, stack))\r\n\t\treturn parts.length > 1 ? parts.join(\" or \") : parts[0]\r\n\t},\r\n\r\n\tformatAssertions = fns => fns.length ? `(${fns.map(f => f.name || f.description || f)})` : \"\",\r\n\r\n\textendDefinition = (def, newParts = []) => {\r\n\t\tif (newParts.length > 0) {\r\n\t\t\tdef = [].concat(def, ...[].concat(newParts))// clone to lose ref\r\n\t\t\t\t.filter((value, index, self) => self.indexOf(value) === index) // remove duplicates\r\n\t\t}\r\n\r\n\t\treturn def\r\n\t},\r\n\r\n\tcheck = (model, obj) => {\r\n\t\tmodel[_check](obj, null, model.errors, [], true);\r\n\t\treturn !unstackErrors(model)\r\n\t},\r\n\r\n\tcheckDefinition = (obj, def, path, errors, stack, shouldCast) => {\r\n\t\tconst indexFound = stack.indexOf(def)\r\n\t\tif (indexFound !== -1 && stack.indexOf(def, indexFound + 1) !== -1)\r\n\t\t\treturn obj // if found twice in call stack, cycle detected, skip validation\r\n\r\n\t\tif (Array.isArray(def) && def.length === 1 && obj != null) {\r\n\t\t\tdef = def[0] // shorten validation path for optionals\r\n\t\t}\r\n\r\n\t\tif (is(Model, def)) {\r\n\t\t\tif (shouldCast) obj = cast(obj, def)\r\n\t\t\tdef[_check](obj, path, errors, stack.concat(def))\r\n\t\t}\r\n\t\telse if (isPlainObject(def)) {\r\n\t\t\tfor (let key in def) {\r\n\t\t\t\tconst val = obj ? obj[key] : undefined\r\n\t\t\t\tcheckDefinition(val, def[key], formatPath(path, key), errors, stack, shouldCast)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tconst pdef = parseDefinition(def)\r\n\t\t\tif (pdef.some(part => checkDefinitionPart(obj, part, path, stack))) {\r\n\t\t\t\treturn shouldCast ? cast(obj, def) : obj\r\n\t\t\t}\r\n\r\n\t\t\tstackError(errors, def, obj, path)\r\n\t\t}\r\n\r\n\t\treturn obj\r\n\t},\r\n\r\n\tcheckDefinitionPart = (obj, def, path, stack, shouldCast) => {\r\n\t\tif (def === Any) return true\r\n\t\tif (obj == null) return obj === def\r\n\t\tif (isPlainObject(def) || is(Model, def)) { // object or model as part of union type\r\n\t\t\tconst errors = []\r\n\t\t\tcheckDefinition(obj, def, path, errors, stack, shouldCast)\r\n\t\t\treturn !errors.length\r\n\t\t}\r\n\t\tif (is(RegExp, def)) return def.test(obj)\r\n\t\tif (def === Number || def === Date) return obj.constructor === def && !isNaN(obj)\r\n\t\treturn obj === def\r\n\t\t\t|| (isFunction(def) && is(def, obj))\r\n\t\t\t|| obj.constructor === def\r\n\t},\r\n\r\n\tcheckAssertions = (obj, model, path, errors = model.errors) => {\r\n\t\tfor (let assertion of model.assertions) {\r\n\t\t\tlet result\r\n\t\t\ttry {\r\n\t\t\t\tresult = assertion.call(model, obj)\r\n\t\t\t} catch (err) {\r\n\t\t\t\tresult = err\r\n\t\t\t}\r\n\t\t\tif (result !== true) {\r\n\t\t\t\tconst onFail = isFunction(assertion.description) ? assertion.description : (assertionResult, value) =>\r\n\t\t\t\t\t`assertion \"${assertion.description}\" returned ${format(assertionResult)} `\r\n\t\t\t\t\t+ `for ${path ? path + \" =\" : \"value\"} ${format(value)}`\r\n\t\t\t\tstackError(errors, assertion, obj, path, onFail.call(model, result, obj, path))\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tformat = (obj, stack = []) => {\r\n\t\tif (stack.length > 15 || stack.includes(obj)) return \"...\"\r\n\t\tif (obj === null || obj === undefined) return String(obj)\r\n\t\tif (isString(obj)) return `\"${obj}\"`\r\n\t\tif (is(Model, obj)) return obj.toString(stack)\r\n\r\n\t\tstack.unshift(obj)\r\n\r\n\t\tif (isFunction(obj)) return obj.name || obj.toString()\r\n\t\tif (is(Map, obj) || is(Set, obj)) return format([...obj])\r\n\t\tif (Array.isArray(obj)) return `[${obj.map(item => format(item, stack)).join(\", \")}]`\r\n\t\tif (obj.toString && obj.toString !== ObjectProto.toString) return obj.toString()\r\n\t\tif (isObject(obj)) {\r\n\t\t\tconst props = Object.keys(obj),\r\n\t\t\t\tindent = \"\\t\".repeat(stack.length)\r\n\t\t\treturn `{${props.map(\r\n\t\t\t\tkey => `\\n${indent + key}: ${format(obj[key], [...stack])}`\r\n\t\t\t).join(\", \")} ${props.length ? `\\n${indent.slice(1)}` : \"\"}}`\r\n\t\t}\r\n\r\n\t\treturn String(obj)\r\n\t},\r\n\r\n\tformatPath = (path, key) => path ? path + \".\" + key : key,\r\n\r\n\tcontrolMutation = (model, def, path, o, key, privateAccess, applyMutation) => {\r\n\t\tconst newPath = formatPath(path, key),\r\n\t\t\tisPrivate = model.conventionForPrivate(key),\r\n\t\t\tisConstant = model.conventionForConstant(key),\r\n\t\t\tisOwnProperty = has(o, key),\r\n\t\t\tinitialPropDescriptor = isOwnProperty && Object.getOwnPropertyDescriptor(o, key)\r\n\r\n\t\tif (key in def && ((isPrivate && !privateAccess) || (isConstant && o[key] !== undefined)))\r\n\t\t\tcannot(`modify ${isPrivate ? \"private\" : \"constant\"} property ${key}`, model)\r\n\r\n\t\tapplyMutation()\r\n\t\tif (has(def, key)) checkDefinition(o[key], def[key], newPath, model.errors, [])\r\n\t\tcheckAssertions(o, model, newPath)\r\n\r\n\t\tconst nbErrors = model.errors.length\r\n\t\tif (nbErrors) {\r\n\t\t\tif (isOwnProperty) Object.defineProperty(o, key, initialPropDescriptor)\r\n\t\t\telse delete o[key] // back to the initial property defined in prototype chain\r\n\r\n\t\t\tunstackErrors(model)\r\n\t\t}\r\n\r\n\t\treturn !nbErrors\r\n\t},\r\n\r\n\tcannot = (msg, model) => {\r\n\t\tmodel.errors.push({ message: \"cannot \" + msg })\r\n\t},\r\n\r\n\tcast = (obj, defNode = []) => {\r\n\t\tif (!obj || isPlainObject(defNode) || is(BasicModel, defNode) || isModelInstance(obj))\r\n\t\t\treturn obj // no value or not leaf or already a model instance\r\n\r\n\t\tconst def = parseDefinition(defNode),\r\n\t\t\tsuitableModels = []\r\n\r\n\t\tfor (let part of def) {\r\n\t\t\tif (is(Model, part) && !is(BasicModel, part) && part.test(obj))\r\n\t\t\t\tsuitableModels.push(part)\r\n\t\t}\r\n\r\n\t\tif (suitableModels.length === 1) {\r\n\t\t\t// automatically cast to suitable model when explicit (autocasting)\r\n\t\t\treturn new suitableModels[0](obj, _checked)\r\n\t\t}\r\n\r\n\t\tif (suitableModels.length > 1)\r\n\t\t\tconsole.warn(`Ambiguous model for value ${format(obj)}, could be ${suitableModels.join(\" or \")}`)\r\n\r\n\t\treturn obj\r\n\t},\r\n\r\n\r\n\tgetProp = (val, model, def, path, privateAccess) => {\r\n\t\tif (!isPlainObject(def)) return cast(val, def)\r\n\t\treturn proxify(val, getTraps(model, def, path, privateAccess))\r\n\t},\r\n\r\n\tgetTraps = (model, def, path, privateAccess) => {\r\n\t\tconst grantPrivateAccess = f => proxify(f, {\r\n\t\t\tapply(fn, ctx, args) {\r\n\t\t\t\tprivateAccess = true\r\n\t\t\t\tconst result = Reflect.apply(fn, ctx, args)\r\n\t\t\t\tprivateAccess = false\r\n\t\t\t\treturn result\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\treturn {\r\n\t\t\tget(o, key) {\r\n\t\t\t\tif (key === _original) return o\r\n\r\n\t\t\t\tif (!isString(key)) return Reflect.get(o, key)\r\n\r\n\t\t\t\tconst newPath = formatPath(path, key)\r\n\t\t\t\tconst inDef = has(def, key)\r\n\t\t\t\tconst defPart = def[key]\r\n\r\n\t\t\t\tif (!privateAccess && inDef && model.conventionForPrivate(key)) {\r\n\t\t\t\t\tcannot(`access to private property ${newPath}`, model)\r\n\t\t\t\t\tunstackErrors(model)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet value = o[key]\r\n\r\n\t\t\t\tif (inDef && value && has(o, key) && !isPlainObject(defPart) && !isModelInstance(value)) {\r\n\t\t\t\t\tReflect.set(o, key, value = cast(value, defPart)) // cast nested models\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isFunction(value) && key !== \"constructor\" && !privateAccess) {\r\n\t\t\t\t\treturn grantPrivateAccess(value)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isPlainObject(defPart) && !value) {\r\n\t\t\t\t\to[key] = value = {} // null-safe traversal\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn getProp(value, model, defPart, newPath, privateAccess)\r\n\t\t\t},\r\n\r\n\t\t\tset(o, key, val) {\r\n\t\t\t\treturn controlMutation(model, def, path, o, key, privateAccess, () => Reflect.set(o, key, cast(val, def[key])))\r\n\t\t\t},\r\n\r\n\t\t\tdeleteProperty(o, key) {\r\n\t\t\t\treturn controlMutation(model, def, path, o, key, privateAccess, () => Reflect.deleteProperty(o, key))\r\n\t\t\t},\r\n\r\n\t\t\tdefineProperty(o, key, args) {\r\n\t\t\t\treturn controlMutation(model, def, path, o, key, privateAccess, () => Reflect.defineProperty(o, key, args))\r\n\t\t\t},\r\n\r\n\t\t\thas(o, key) {\r\n\t\t\t\treturn Reflect.has(o, key) && Reflect.has(def, key) && !model.conventionForPrivate(key)\r\n\t\t\t},\r\n\r\n\t\t\townKeys(o) {\r\n\t\t\t\treturn Reflect.ownKeys(o).filter(key => Reflect.has(def, key) && !model.conventionForPrivate(key))\r\n\t\t\t},\r\n\r\n\t\t\tgetOwnPropertyDescriptor(o, key) {\r\n\t\t\t\tlet descriptor\r\n\t\t\t\tif (!model.conventionForPrivate(key)) {\r\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(def, key)\r\n\t\t\t\t\tif (descriptor !== undefined) descriptor.value = o[key]\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn descriptor\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\nexport function Model(def, params) {\r\n\treturn isPlainObject(def) ? new ObjectModel(def, params) : new BasicModel(def)\r\n}\r\n\r\nObject.assign(Model.prototype, {\r\n\tname: \"Model\",\r\n\tassertions: [],\r\n\r\n\tconventionForConstant: key => key.toUpperCase() === key,\r\n\tconventionForPrivate: key => key[0] === \"_\",\r\n\r\n\ttoString(stack) {\r\n\t\treturn has(this, \"name\") ? this.name : formatDefinition(this.definition, stack) + formatAssertions(this.assertions)\r\n\t},\r\n\r\n\tas(name) {\r\n\t\tdefine(this, \"name\", name)\r\n\t\treturn this\r\n\t},\r\n\r\n\tdefaultTo(val) {\r\n\t\tthis.default = val\r\n\t\treturn this\r\n\t},\r\n\r\n\t[_check](obj, path, errors, stack) {\r\n\t\tcheckDefinition(obj, this.definition, path, errors, stack)\r\n\t\tcheckAssertions(obj, this, path, errors)\r\n\t},\r\n\r\n\ttest(obj, errorCollector) {\r\n\t\tlet model = this\r\n\t\twhile (!has(model, \"errorCollector\")) {\r\n\t\t\tmodel = getProto(model)\r\n\t\t}\r\n\r\n\t\tconst initialErrorCollector = model.errorCollector\r\n\t\tlet failed\r\n\r\n\t\tmodel.errorCollector = errors => {\r\n\t\t\tfailed = true\r\n\t\t\tif (errorCollector) errorCollector.call(this, errors)\r\n\t\t}\r\n\r\n\t\tnew this(obj) // may trigger errorCollector\r\n\r\n\t\tmodel.errorCollector = initialErrorCollector\r\n\t\treturn !failed\r\n\t},\r\n\r\n\terrorCollector(errors) {\r\n\t\tconst e = new TypeError(errors.map(e => e.message).join(\"\\n\"))\r\n\t\te.stack = e.stack.replace(/\\n.*object-model(.|\\n)*object-model.*/, \"\") // blackbox objectmodel in stacktrace\r\n\t\tthrow e\r\n\t},\r\n\r\n\tassert(assertion, description = format(assertion)) {\r\n\t\tdefine(assertion, \"description\", description)\r\n\t\tthis.assertions = this.assertions.concat(assertion)\r\n\t\treturn this\r\n\t}\r\n})\r\n\r\nModel.CHECK_ONCE = CHECK_ONCE\r\n\r\nexport function BasicModel(def) {\r\n\treturn initModel(def, BasicModel)\r\n}\r\n\r\nextend(BasicModel, Model, {\r\n\textend(...newParts) {\r\n\t\tconst child = extendModel(new BasicModel(extendDefinition(this.definition, newParts)), this)\r\n\t\tfor (let part of newParts) {\r\n\t\t\tif (is(BasicModel, part)) child.assertions.push(...part.assertions)\r\n\t\t}\r\n\r\n\t\treturn child\r\n\t}\r\n})\r\n\r\nexport function ObjectModel(def) {\r\n\treturn initModel(def, ObjectModel, Object, initObjectModel, model => getTraps(model, def), true)\r\n}\r\n\r\nextend(ObjectModel, Model, {\r\n\tdefaultTo(obj) {\r\n\t\tconst def = this.definition\r\n\t\tfor (let key in obj) {\r\n\t\t\tif (has(def, key)) {\r\n\t\t\t\tobj[key] = checkDefinition(obj[key], def[key], key, this.errors, [], true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tunstackErrors(this)\r\n\t\tthis.default = obj;\r\n\t\treturn this\r\n\t},\r\n\r\n\ttoString(stack) {\r\n\t\treturn format(this.definition, stack)\r\n\t},\r\n\r\n\textend(...newParts) {\r\n\t\tconst definition = { ...this.definition }\r\n\t\tconst proto = { ...this.prototype }\r\n\t\tconst defaults = { ...this.default }\r\n\t\tconst newAssertions = []\r\n\r\n\t\tfor (let part of newParts) {\r\n\t\t\tif (is(Model, part)) {\r\n\t\t\t\tmerge(definition, part.definition)\r\n\t\t\t\tmerge(defaults, part.default)\r\n\t\t\t\tnewAssertions.push(...part.assertions)\r\n\t\t\t}\r\n\t\t\tif (isFunction(part)) merge(proto, part.prototype)\r\n\t\t\tif (isObject(part)) merge(definition, part)\r\n\t\t}\r\n\r\n\t\tconst submodel = extendModel(new ObjectModel(definition), this, proto).defaultTo(defaults)\r\n\t\tsubmodel.assertions = [...this.assertions, ...newAssertions]\r\n\r\n\t\tif (getProto(this) !== ObjectModel.prototype) { // extended class\r\n\t\t\tsubmodel.parentClass = this\r\n\t\t}\r\n\r\n\t\treturn submodel\r\n\t},\r\n\r\n\t[_check](obj, path, errors, stack, shouldCast) {\r\n\t\tif (isObject(obj)) {\r\n\t\t\tcheckDefinition(obj[_original] || obj, this.definition, path, errors, stack, shouldCast)\r\n\t\t}\r\n\t\telse stackError(errors, this, obj, path)\r\n\r\n\t\tcheckAssertions(obj, this, path, errors)\r\n\t}\r\n})\r\n\r\nexport const Any = proxify(BasicModel(), {\r\n\tapply(target, ctx, [def]) {\r\n\t\tconst anyOf = Object.create(Any)\r\n\t\tanyOf.definition = def;\r\n\t\treturn anyOf\r\n\t}\r\n})\r\nAny.definition = Any\r\nAny.toString = () => \"Any\"\r\n\r\nAny.remaining = function (def) { this.definition = def }\r\nextend(Any.remaining, Any, {\r\n\ttoString() { return \"...\" + formatDefinition(this.definition) }\r\n})\r\nAny[Symbol.iterator] = function* () { yield new Any.remaining(this.definition) }","\nimport { _original, checkAssertions, checkDefinition, initModel, unstackErrors } from \"./object-model.js\"\nimport { has, isFunction, proxify } from \"./helpers.js\"\n\nexport const initListModel = (base, constructor, def, init, clone, mutators, otherTraps) => {\n\n\treturn initModel(def, constructor, base, init, model => Object.assign({\n\t\tgetPrototypeOf: () => model.prototype,\n\t\tget(l, key) {\n\t\t\tif (key === _original) return l\n\n\t\t\tconst val = l[key]\n\t\t\treturn isFunction(val) ? proxify(val, {\n\t\t\t\tapply(fn, ctx, args) {\n\t\t\t\t\tif (has(mutators, key)) {\n\t\t\t\t\t\t// indexes of arguments to check def + cast\n\t\t\t\t\t\tconst [begin, end = args.length - 1, getArgDef] = mutators[key]\n\t\t\t\t\t\tfor (let i = begin; i <= end; i++) {\n\t\t\t\t\t\t\tconst argDef = getArgDef ? getArgDef(i) : model.definition\n\t\t\t\t\t\t\targs[i] = checkDefinition(\n\t\t\t\t\t\t\t\targs[i],\n\t\t\t\t\t\t\t\targDef,\n\t\t\t\t\t\t\t\t`${base.name}.${key} arguments[${i}]`,\n\t\t\t\t\t\t\t\tmodel.errors,\n\t\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (model.assertions.length > 0) {\n\t\t\t\t\t\t\tconst testingClone = clone(l)\n\t\t\t\t\t\t\tfn.apply(testingClone, args)\n\t\t\t\t\t\t\tcheckAssertions(testingClone, model, `after ${key} mutation`)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tunstackErrors(model)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(l, args)\n\t\t\t\t}\n\t\t\t}) : val\n\t\t}\n\t}, otherTraps))\n}","import {\n\t_original, _check, cast, checkAssertions, checkDefinition,\n\textendDefinition, extendModel, formatDefinition, Model, stackError, unstackErrors\n} from \"./object-model.js\"\nimport { initListModel } from \"./list-model.js\"\nimport { extend } from \"./helpers.js\"\n\nexport default function ArrayModel(initialDefinition) {\n\tconst model = initListModel(\n\t\tArray,\n\t\tArrayModel,\n\t\tinitialDefinition,\n\t\ta => Array.isArray(a) ? a.map(arg => cast(arg, model.definition)) : a,\n\t\ta => [...a],\n\t\t{\n\t\t\t\"copyWithin\": [],\n\t\t\t\"fill\": [0, 0],\n\t\t\t\"pop\": [],\n\t\t\t\"push\": [0],\n\t\t\t\"reverse\": [],\n\t\t\t\"shift\": [],\n\t\t\t\"sort\": [],\n\t\t\t\"splice\": [2],\n\t\t\t\"unshift\": [0]\n\t\t},\n\t\t{\n\t\t\tset(arr, key, val) {\n\t\t\t\treturn controlMutation(model, arr, key, val, (a, v) => a[key] = v, true)\n\t\t\t},\n\n\t\t\tdeleteProperty(arr, key) {\n\t\t\t\treturn controlMutation(model, arr, key, undefined, a => delete a[key])\n\t\t\t}\n\t\t}\n\t)\n\n\treturn model\n}\n\nextend(ArrayModel, Model, {\n\ttoString(stack) {\n\t\treturn \"Array of \" + formatDefinition(this.definition, stack)\n\t},\n\n\t[_check](arr, path, errors, stack) {\n\t\tif (Array.isArray(arr))\n\t\t\t(arr[_original] || arr).forEach((a, i) => checkDefinition(a, this.definition, `${path || \"Array\"}[${i}]`, errors, stack))\n\t\telse stackError(errors, this, arr, path)\n\n\t\tcheckAssertions(arr, this, path, errors)\n\t},\n\n\textend(...newParts) {\n\t\treturn extendModel(new ArrayModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})\n\nconst controlMutation = (model, array, key, value, applyMutation, canBeExtended) => {\n\tconst path = `Array[${key}]`\n\tconst isInDef = (+key >= 0 && (canBeExtended || key in array))\n\tif (isInDef) value = checkDefinition(value, model.definition, path, model.errors, [], true)\n\n\tconst testArray = [...array]\n\tapplyMutation(testArray)\n\tcheckAssertions(testArray, model, path)\n\tconst isSuccess = !unstackErrors(model)\n\tif (isSuccess) applyMutation(array, value)\n\treturn isSuccess\n}","import {\n\t_check, _original, Any, checkAssertions, checkDefinition, extendDefinition, extendModel,\n\tformatDefinition, initModel, Model, stackError, unstackErrors\n} from \"./object-model.js\"\nimport { extend, is, isFunction } from \"./helpers.js\"\n\nexport default function FunctionModel(...argsDef) {\n\treturn initModel({ arguments: argsDef }, FunctionModel, Function, null, model => ({\n\t\tgetPrototypeOf: () => model.prototype,\n\n\t\tget(fn, key) {\n\t\t\treturn key === _original ? fn : fn[key]\n\t\t},\n\n\t\tapply(fn, ctx, args) {\n\t\t\tconst def = model.definition\n\t\t\tconst remainingArgDef = def.arguments.find(argDef => is(Any.remaining, argDef))\n\t\t\tconst nbArgsToCheck = remainingArgDef ? Math.max(args.length, def.arguments.length - 1) : def.arguments.length\n\n\t\t\tfor (let i = 0; i < nbArgsToCheck; i++) {\n\t\t\t\tconst argDef = remainingArgDef && i >= def.arguments.length - 1 ? remainingArgDef.definition : def.arguments[i]\n\t\t\t\targs[i] = checkDefinition(args[i], argDef, `arguments[${i}]`, model.errors, [], true)\n\t\t\t}\n\n\t\t\tcheckAssertions(args, model, \"arguments\")\n\n\t\t\tlet result\n\t\t\tif (!model.errors.length) {\n\t\t\t\tresult = Reflect.apply(fn, ctx, args)\n\t\t\t\tif (\"return\" in def)\n\t\t\t\t\tresult = checkDefinition(result, def.return, \"return value\", model.errors, [], true)\n\t\t\t}\n\t\t\tunstackErrors(model)\n\t\t\treturn result\n\t\t}\n\t}))\n}\n\nextend(FunctionModel, Model, {\n\ttoString(stack = []) {\n\t\tlet out = `Function(${this.definition.arguments.map(\n\t\t\targDef => formatDefinition(argDef, [...stack])\n\t\t).join(\", \")})`\n\n\t\tif (\"return\" in this.definition) {\n\t\t\tout += \" => \" + formatDefinition(this.definition.return, stack)\n\t\t}\n\t\treturn out\n\t},\n\n\treturn(def) {\n\t\tthis.definition.return = def\n\t\treturn this\n\t},\n\n\textend(newArgs, newReturns) {\n\t\tconst args = this.definition.arguments,\n\t\t\t  mixedArgs = newArgs.map((a, i) => extendDefinition(i in args ? args[i] : [], newArgs[i])),\n\t\t\t  mixedReturns = extendDefinition(this.definition.return, newReturns)\n\t\treturn extendModel(new FunctionModel(...mixedArgs).return(mixedReturns), this)\n\t},\n\n\t[_check](f, path, errors) {\n\t\tif (!isFunction(f)) stackError(errors, \"Function\", f, path)\n\t}\n})","import {\n\t_check, cast, checkAssertions, checkDefinition,\n\textendDefinition, extendModel, format, formatDefinition, Model, stackError\n} from \"./object-model.js\"\nimport { initListModel } from \"./list-model.js\"\nimport { extend, is, isIterable } from \"./helpers.js\"\n\nexport default function MapModel(initialKeyDefinition, initialValueDefinition) {\n\tconst getDef = i => i === 0 ? model.definition.key : model.definition.value;\n\tconst model = initListModel(\n\t\tMap,\n\t\tMapModel,\n\t\t{ key: initialKeyDefinition, value: initialValueDefinition },\n\t\tit => isIterable(it) ? new Map([...it].map(pair => pair.map((x, i) => cast(x, getDef(i))))) : it,\n\t\tmap => new Map(map),\n\t\t{\n\t\t\t\"set\": [0, 1, getDef],\n\t\t\t\"delete\": [],\n\t\t\t\"clear\": []\n\t\t}\n\t)\n\n\treturn model\n}\n\nextend(MapModel, Model, {\n\ttoString(stack) {\n\t\treturn `Map of ${formatDefinition(this.definition.key, stack)} : ${formatDefinition(this.definition.value, stack)}`\n\t},\n\n\t[_check](map, path, errors, stack) {\n\t\tif (is(Map, map)) {\n\t\t\tpath = path || \"Map\"\n\t\t\tfor (let [key, value] of map) {\n\t\t\t\tcheckDefinition(key, this.definition.key, `${path} key`, errors, stack)\n\t\t\t\tcheckDefinition(value, this.definition.value, `${path}[${format(key)}]`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, map, path)\n\n\t\tcheckAssertions(map, this, path, errors)\n\t},\n\n\textend(keyParts, valueParts) {\n\t\treturn extendModel(new MapModel(\n\t\t\textendDefinition(this.definition.key, keyParts),\n\t\t\textendDefinition(this.definition.value, valueParts)\n\t\t), this)\n\t}\n})","import {\n\t_check, cast, checkAssertions, checkDefinition,\n\textendDefinition, extendModel, formatDefinition, Model, stackError\n} from \"./object-model.js\"\nimport { initListModel } from \"./list-model.js\"\nimport { extend, is, isIterable } from \"./helpers.js\"\n\nexport default function SetModel(initialDefinition) {\n\tconst model = initListModel(\n\t\tSet,\n\t\tSetModel,\n\t\tinitialDefinition,\n\t\tit => isIterable(it) ? new Set([...it].map(val => cast(val, model.definition))) : it,\n\t\tset => new Set(set),\n\t\t{\n\t\t\t\"add\": [0, 0],\n\t\t\t\"delete\": [],\n\t\t\t\"clear\": []\n\t\t}\n\t)\n\n\treturn model\n}\n\nextend(SetModel, Model, {\n\ttoString(stack) {\n\t\treturn \"Set of \" + formatDefinition(this.definition, stack)\n\t},\n\n\t[_check](set, path, errors, stack) {\n\t\tif (is(Set, set)) {\n\t\t\tfor (let item of set.values()) {\n\t\t\t\tcheckDefinition(item, this.definition, `${path || \"Set\"} value`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, set, path)\n\t\tcheckAssertions(set, this, path, errors)\n\t},\n\n\textend(...newParts) {\n\t\treturn extendModel(new SetModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})"],"names":["ObjectProto","Object","prototype","getProto","getPrototypeOf","setProto","setPrototypeOf","has","o","prop","hasOwnProperty","call","is","Constructor","obj","isFunction","f","isObject","isString","s","isPlainObject","isIterable","x","Symbol","iterator","proxify","val","traps","Proxy","merge","target","src","key","define","value","enumerable","defineProperty","writable","configurable","extend","child","parent","props","assign","create","constructor","_check","_checked","_original","CHECK_ONCE","initModel","def","init","getTraps","useNew","model","default","mode","this","check","definition","assertions","name","initObjectModel","_this","undefined","stackError","errors","parentClass","extendModel","newProps","push","expected","received","path","message","unstackErrors","collector","errorCollector","nbErrors","length","map","err","formatDefinition","toString","match","format","isModelInstance","i","Model","parseDefinition","Array","isArray","stack","parts","d","join","extendDefinition","newParts","concat","filter","index","self","indexOf","checkDefinition","shouldCast","indexFound","cast","formatPath","some","part","checkDefinitionPart","Any","RegExp","test","Number","Date","isNaN","checkAssertions","assertion","result","onFail","description","assertionResult","includes","String","unshift","Map","Set","item","keys","indent","repeat","slice","controlMutation","privateAccess","applyMutation","newPath","isPrivate","conventionForPrivate","isConstant","conventionForConstant","isOwnProperty","initialPropDescriptor","getOwnPropertyDescriptor","cannot","msg","defNode","BasicModel","suitableModels","console","warn","get","Reflect","inDef","defPart","set","apply","fn","ctx","args","getProp","deleteProperty","ownKeys","descriptor","params","ObjectModel","toUpperCase","fns","as","defaultTo","initialErrorCollector","failed","e","TypeError","replace","assert","proto","defaults","newAssertions","submodel","anyOf","remaining","initListModel","base","clone","mutators","otherTraps","l","begin","end","getArgDef","argDef","testingClone","ArrayModel","initialDefinition","a","arg","copyWithin","fill","pop","reverse","shift","sort","splice","arr","v","forEach","array","canBeExtended","testArray","isSuccess","FunctionModel","argsDef","arguments","Function","remainingArgDef","find","nbArgsToCheck","Math","max","return","MapModel","initialKeyDefinition","initialValueDefinition","getDef","it","pair","delete","clear","SetModel","add","out","newArgs","newReturns","mixedArgs","mixedReturns","keyParts","valueParts","values"],"mappings":"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"}